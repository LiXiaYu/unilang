$import! std.io newline load display puts;
$import! std.strings ++;

$defl! putss (.&xs) puts (apply ++ xs);

$defl! stoi-exact (&x)
	$let ((&r stoi x))
		$if (eqv? (itos r) x) (forward! r)
			(raise-error "Invalid integer representation found.");

$defl! info (.&msgs) apply putss (list* "Test case: " (move! msgs));
$defl! subinfo (.&msgs) apply putss (list* "Sub test case: " (move! msgs));

$def! Unilang_TestOpts_QuickFail #t;
$def! report-failure $if Unilang_TestOpts_QuickFail raise-error puts;
$defl! pass (.) puts "PASS.";
$defl! fail-on-check (&expr &res) $sequence
	(puts "FAIL: Check failed, with the expression:")
	(display expr)
	(() newline)
	(puts "  with the result:")
	(display res)
	(() newline)
	(report-failure "Test case failed.");
$defl! fail-on-expect (&expr &res &expected) $sequence
	(puts "FAIL: Check failed, with the expression:")
	(display expr)
	(() newline)
	(puts "  with the result:")
	(display (forward! res))
	(() newline)
	(puts "  expected result:")
	(display (forward! expected))
	(() newline)
	(report-failure "Test case failed.");
$defv! $check (.&expr) d
	$let ((res eval expr d))
		$if (res) (pass res) (fail-on-check expr res);
$defv! $expect (&expected-expr .&expr) d
	$let ((&res eval expr d) (&expected eval expected-expr d))
		$if (equal? res expected) (pass res)
			(fail-on-expect expr (forward! res) (forward! expected));

$provide/let! (version? string->version version->string version<?)
((mods $as-environment (
	$import! std.strings &++ &string-split;

	$def! (encapsulate% version? decapsulate)
		() make-encapsulation-type,
	$defl! semver->string (&x)
		$let (((xmajor xminor xpatch) x))
			++ (itos xmajor) "." (itos xminor) "." (itos xpatch),
	$defl! semver<? (&x &y)
		$let (((xmajor xminor xpatch) x) ((ymajor yminor ypatch) y))
			$or? (<? xmajor ymajor) ($and? (=? xmajor ymajor)
				($or? (<? xminor yminor) ($and? (=? xminor yminor)
				(<? xpatch ypatch)))),
	$defl! semver-parse (&x)
		$let* ((normalized string-split x "-")
			(ls string-split (first normalized) ".")
			((smajor sminor spatch) ls))
			map1 stoi-exact ls
)))
(
	$import! mods &version?,
	$defl/e! string->version mods (&x) encapsulate% (idv (semver-parse x)),
	$defl/e! version->string mods (&x) semver->string (decapsulate x),
	$defl/e! version<? mods (&x &y) semver<? (decapsulate x) (decapsulate y)
);

$provide/let! (dependency? make-dependency name-of version-of check-of validate)
((mods $as-environment (
	$def! (encapsulate% dependency? decapsulate)
		() make-encapsulation-type
)))
(
	$import! mods &dependency?,
	$defl/e! make-dependency mods (&name &ver &check)
		encapsulate% (list name ver check),
	$defl/e! name-of mods (&dep) idv (first (decapsulate dep)),
	$defl/e! version-of mods (&dep) idv (first (rest& (decapsulate dep))),
	$defl/e! check-of mods (&dep) idv (first (rest& (rest& (decapsulate dep)))),
	$defl/e! validate mods (&dep .&deps) apply (check-of dep) deps
);

