# 前言(Foreword)

　　本文档是 Unilang 语言的设计规格说明。

## 体例说明

　　本文档中的特定文本（主要用于源代码）使用 `引用文本` 指定。非引用的正常文本适用以下体例。

　　局部的 *术语(terms)* 和 **强调** 的文本以特定的不同于其它正文的格式显示。

　　外部的引用以[超链接](https://zh.wikipedia.org/zh-cn/%E8%B6%85%E9%93%BE%E6%8E%A5)指定。全文外部引用另见以下的正式引用(normative references) 章节。

　　部分术语或其它名词性文本的特定义项首次出现时使用半角括号标注对应的英文翻译供参照。首字母缩略语(acronym) 和非局部概念的标题使用翻译时，词首字母大写。

　　本文档指定的语言规则(language rule) 中的形式文法(formal grammar) 包括形式语法(formal syntax) 和特定操作的形式，不提供附加的形式语义(formal semantic) 。

　　形式语法的语法类别(syntax category) 以 [BNF](https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F) 推导规则表示。

# 绪论(Introduction)

　　Unilang 是一门现代的、模块化的、可移植的和可扩展的通用目的编程语言。

　　Unilang 提供*基础语言(base language)* 和*语言扩展(language extension)* 。基础语言指定基本的语言规则；语言扩展在基础语言之上提供附加的规则，补充或改变语言的特定特性，提供比基础语言更多的实用功能。

## 范围(Scope)

　　本文档定义基础语言的语言规则。

　　在基础语言上附加语言扩展得到的*派生语言实现(derivative language implementation)* 可具有不同的语言规则，但应满足本文档中的最小*要求(requirements)* 以维持*符合性(conformance)* 。

　　派生语言实现是语言的设计，是抽象的实现。基础语言和派生语言实现都可能有非语言设计形式的具体实现（例如*解释器(interpreter)* ）。不致混淆时，派生语言实现简称*派生实现(derived implementation)* 。一般地，Unilang 语言的*实现(implementation)* 指非语言设计形式的具体实现以及基础语言的派生实现。

　　除非另行指定(specified otherwise) ，本文档的语言规则同时适用于基础语言和派生实现。

## 正式引用

　　本章引用本文档使用的外部参考(external reference) ，包含不被局部术语涵盖的一般解释。包括：

* ISO/IEC 2382 (all parts), Information technology — Vocabulary
* ISO/IEC 14882:2017, Information technology — Programming languages — C++
* [Fexprs as the basis of Lisp function application or $vau : the ultimate abstraction](http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf) ([Shu10])

* [ISO C++] ISO/IEC 14882
* [ISO 2382] ISO/IEC 2382

# 术语和定义(Terms and Definitions)

* **行为(behavior)** 语言实现或在满足符合性的具体语言实现中的程序的外部表现。
* **程序(program)** 具体语言实现接受的以代码表示的输入，或被变换后对应的输出。
	* 语言实现支持运行*程序(program)* 。除非另行指定，程序指符合本文档要求的 Unilang 代码的输入程序，即 Unilang *源程序(source program)* 。
**诊断(diagnostics)** 明确的对特定预期或非预期执行的行为的响应的总和。
**诊断消息(diagnostic message)** 用于和用户交互的表现诊断的告知及提示。
**未定义的(undefined)** 可能导致违反语言规范的约束但语言规范同时没有要求提供任何可能影响符合性的保证（如具有诊断消息）的。
	* 表示置于语言规则下的行为等不可预测。
**未指定的(unspecified)** 在各个实现中可能存在的，通常允许多种不同的实现选项。
	* 不应假定不同实现在明确未指定的规则上表现一致。
**由实现定义的(implementation-defined)** 取决于各个具体语言实现的，要求有文档说明。
**由派生实现定义的(derived-implementation-defined)** 取决于各个具体派生实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。
**未定义行为(undefined behavior)** 未定义的行为。
**未指定行为(unspecified behavior)** 未指定的行为，由实现选取规格中可能允许的指定行为的不确定选项，后者可能由显式或隐式的语言规则确定。

# 计算模型

　　本文档的 Unilang 语义规则以*抽象机(abstract machine)* 的形式提供。抽象机可具有*可变状态(mutable state)* 。

　　Unilang 程序的*执行(execution)* 可包括不同的*计算作用(computational effect)* ，包括：

* 确定一个作为计算结果的*值(value)* 。
* 改变抽象机中的可变状态。

　　后者称为*副作用(side effect)* ，包括：

* 特定的对象访问：改变抽象机中的可被程序*访问(access)* 的可变状态。
* *控制作用(control effect)* ：改变之后会被执行的程序。

　　派生实现可定义其它的作用。

　　除非另行指定，副作用构成实现接受程序时具有的*可观察(observable) 行为*。

# 符合性(Conformance)

　　本文档指定 Unilang 程序的语言规则，包括语法和语义规则。

　　Unilang 的实现翻译程序到适当的目标代码的形式。翻译的输入是源程序。翻译的直接输出可能是外部环境不可见的，即*解释(interpret)* ；也可以是确定具体形式的，即*编译(compile)* 。

　　一个符合本文档的实现应支持能接受符合规则的程序作为翻译的输入，并按本文档约定的规则中的要求表现计算作用影响的行为。

　　特定的程序是 AOT(ahead-of-time) 翻译的，翻译总在执行时的余下阶段之前进行，余下的阶段运行程序。基础语言是否使用 AOT 翻译实现未指定。

　　若程序具有未定义行为，则对实现没有任何要求，包括是否接受源程序的判定。

　　Unilang 要求具体实现对不满足语言规则约束的特定情形给出诊断。这类规则是*可诊断的(diagnostable)* 。

　　本文档中，*引起(signal)* 指定为*错误(error)* 的条件明确要求诊断。

　　违反语法规则的的情形是错误。

　　程序的语法性质和部分语义性质在翻译时检查，通过检查则应接受翻译，否则应提供诊断。

　　一次翻译接受的源代码是一个*翻译单元(translation unit)* 。对语法规则的检查以不大于翻译单元的单位整体进行。对未通过语法规则检查的诊断应至少能明确区分具体失败的翻译单元。

　　Unilang 具体实现应满足以下最小符合性要求：

* 以翻译单元为单位进行翻译，满足：
	* 翻译接受*合式的(well-formed)* ，即符合语法规则和可诊断语义规则的程序。
	* 对*不合式的(ill-formed)* 程序，若不存在未定义行为，则要求翻译提供诊断消息并拒绝接受程序而终止程序的运行。（对 AOT 翻译实现，则直接终止翻译。）
* 对合式的程序，具体实现的行为符合抽象机语义蕴含的可观察行为。

　　注意可观察行为以外的具体实现行为和抽象机的行为的一致性未指定。这允许*优化的(optimimal)* 实现省略不影响可观察行为的计算作用。

# 词法规则(Lexical Rules)

　　Unilang 基础语言以空白符作为翻译单元中*词素(lexeme)* 的间隔。识别词素后，每个词素按照构成字符的不同，被分为不同的*记号(token)* 类别。

　　记号类别包含*标点(punctuator)* 、*字面量(literal)* 和*标识符(identifier)* 。

　　基础语言识别的标点包括 `(` 和 `)` 。

　　字面量包括：

* 以 `"` 作为词素起始和结尾的*字符串字面量(string literal)* 。
* 以 0~9 组成的十进制整数数值字面量。
* `#t` 和 `#f` 表示逻辑真和逻辑假。
* `#inert` 指定特定操作中表示被忽略的结果。

　　派生实现可在此之外定义其它记号类型和扩展的标点，后者应符合 C++ ([ISO C++]) 的定义。

　　派生实现也可定义*预处理(preprocessing)* 过程翻译其它表示为包含 Unilang 基础语言接受的词法形式的翻译单元。

# 语法

　　Unilang 基础语言的语法以基本语法和可通过前置预处理实现的*中缀变换(infix transformation)* 规则定义。

## 基本语法

<expression> ::= <atom-expression> | <composite-expression> | <list-expression>
<composite-expression> ::= <token-expression> | <expression-token>
<atom-expression> ::= <token>
<list-expression> ::= <left-list-bound> <expression>* <right-list-bound>
<left-list-bound> ::= `(` | <extended-left-list-bound>
<right-list-bound> ::= `)` | <extended-right-list-bound>

　　Unilang 基础语言的翻译单元以*表达式(expression)* 作为语法单位。一个表达式可以是：

* 不可拆分为其它表达式的*原子表达式(atom expression)* 。
* 由派生实现定义的，记号和其它表达式直接*并置连接(juxtaposition)* ，之间没有其它记号的表达式。
* 由分隔符作为边界的包含若干个*子表达式(subexpression)* 的*列表表达式(list expression)* 。

　　原子表达式在词法上是一个记号。

　　以下词法构造在基础语言中是空集，可由派生实现定义：

* <extended-left-list-bound>
* <extended-right-list-bound>
* <token-expression>
* <expression-token>

## 中缀变换

　　中缀变换替换形如 <expression> (<infix> <expression>)* 的记号序列为 <transformed-infix> <expression>+ 形式的记号序列。

　　其中，基础语言支持的中缀记号 <infix> 是 `;` 或 `,` ，而 <transformed-infix> 是语法不可见的中缀变换函数。

　　变换的不同 <expression> 的实例以相同的词法顺序在变换后的结果中被保存。

　　变换后的结果符合以上的基本语法规则。

# 语义

## 实体模型

　　Unilang 的程序操作*实体(entity)* 。

　　区分*同一性(identity)* 的实体是*对象(object)*。同一性决定语言的不同表达式可以描述的相同的对象。

　　不区分同一性的特定的实体是*值(value)* 。值可以具有*类型(type)* 以明确*外延(extension)*（一般建模为集合）。

　　对象可能具有*可变(mutable)* 状态，是可变的对象；对象也可能总是具有一种不被预言分辨的状态，是*不可变(immutable)* 的。其它实体是不可变的。

　　可变对象允许*改变(mutate)* 使对象具有不同的状态。

　　语言实现可定义其它的机制明确同一性或外延的其它实体。

　　类型是一种值，其外延是类型*全集(universe)* 。

　　除非另行指定，不相同的类型的值之间不相等。

　　对象总是关联特定*类型(type)* 的值作为它的内容，称为对象的值。

　　对象的值是对象的状态的一部分。对象的值的不可变性蕴含对象的不可变性，但反之不保证。这允许实现在对象中保存不影响值但仍可影响可观察行为的状态（例如同步需要的锁定状态）。

　　因为明确同一性，特定的对象实例总是可被*创建(create)* 或*销毁(destroy)* ，且可能影响可观察行为。

　　程序执行时，每个被创建后和销毁前的对象具有一段连续的*生存期(lifetime)* 。

　　确定对象的值或改变对象的值访问对象。

　　在生存期外访问对象是受限的；除非另行指定，在生存期外访问对象的程序具有未定义行为。

　　一个或多个对象可具有另一个对象的*所有权(ownership)* ：前者约束后者的创建和销毁的时机。被所有的对象的生存期是所有者的生存期的并集的子集。

　　一个对象可以具有若干个*子对象(subobject)* ，在创建后创建子对象，在销毁前销毁子对象，而具有子对象的所有权。

　　类似地，对象可以对内部的非一等对象的资源实体具有所有权。

　　所有权作为实体上的二元关系，满足反自反、反对称和传递性。

## 表达式的值和*值类别(value category)*

　　表达式通过*求值(evaluation)* 进行计算并体现计算作用，其中可确定表达式的计算结果作为关联的值，即表达式的值。

　　在语法规则之上，基础语言约定可能*未求值的(unevaluated)* 表达式作为对象也具有值。未求值的表达式满足以下性质：

* 作为记号的标识符是*符号(symbol*) ，是符号类型的值。
* 列表表达式中若不含有子表达式，则这个表达式是空列表；否则，是非空列表。

　　空列表和非空列表统称列表，其中包含的子对象是列表的元素。未求值的非空列表中，子表达式是列表的元素。

　　Unilang 的列表是*真列表(proper list)* ：列表的元素有限，同一个列表的不同元素之间不具有相互的所有权，生存期不相交。

　　特定的值是*引用值(reference value)* ，具有引用类型。引用类型和其它对象的类型不同。但除非另行指定，访问引用值总是等价于访问其*被引用对象(referent)* 。类似 [ISO C++] ，这称为*左值到右值转换(lvalue-to-rvalue conversion)* 。例外而不进行这种转换的上下文中，引用值被保留。

　　具有引用值的表达式是*左值(lvalue)* ，否则是*右值(rvalue)* 。

　　执行时引入循环引用的程序具有未定义行为。

## 变量(variable) 和环境(environment)

　　变量是具有*名称(name)* 的实体，参见 [ISO 2382]。

　　基础语言中，变量是在*环境* 类型的对象中存储的*绑定(binding)* 的集合，即名称到实体的映射。

　　环境对其中的变量绑定中的对象具有所有权。

　　环境可以具有零个或有限多个父环境。环境的父环境在创建时指定，之后不可变。

　　给定一个名称，在环境中确定被名称指称的对象，称为*名称解析(name resolution)* 。

　　基础语言使用以下名称解析算法：

1. 若在指定的环境中存在指定的名称对应的绑定，绑定的对象是名称查找的结果对象。
2. 否则，按创建环境时指定的顺序，深度优先搜索父环境中的绑定，搜索到的第一个确定对应的绑定的对象是名称查找的结果对象。
3. 否则，名称解析失败，引起错误。

　　成功的解析确定的对象以引用这个对象的引用值表示。

　　名称解析的深度优先搜索规则支持*词法作用域(lexical scoping)* 和*名称隐藏(name hiding)* 的实现。

　　求值 Unilang 表达式时总应存在一个环境，称为*当前环境(current environment)* ，作为名称解析算法的初始输入。

　　语言实现为程序开始运行时的具有的当前环境称为*初始环境(initial environment)* 。

## 合并子(combiner)

　　合并子是在特定表达式中出现的可被求值时*调用(invoke)* 的对象。

　　合并子的调用接受*操作数(operand)* 实体，其中每个子对象作为*实际参数(actual argument)* ，进行计算。

　　合并子分为两类：

* 调用时总是先对每个实际参数求值，然后调用*底层(underlying)* 合并子。这种合并子是*应用合并子(applicative combiner)* 简称*应用子(applicative)* 。
* 否则，合并子是*操作合并子(operative combiner)* ，简称*操作子(operative)* 。

　　应用子的底层合并子可以是其它应用子，即参数求值可能发生多次。

　　操作子调用匹配参数，可要求操作数符合一定的结构，否则引发参数不匹配的错误。

　　匹配参数后的操作子调用的具体行为由具体合并子对象确定。这可在创建合并子对象时决定。

　　合并子的*正常(normal)* 调用总是可确定一个计算结果，作为求值的结果。除非另行指定，若求值结果为引用值，则*提升(lift)* 为被引用对象的值。这避免返回*悬空引用(danling reference)* 。

　　合并子的*非正常(abnormal)* 调用不确保调用结果。

　　非正常调用的控制被转移到需要调用的求值表达式之外，这可以发生在引起错误时。

　　关于合并子的形式理论，参见 [Shu10] 。

## 求值算法

　　基础语言使用以下统一的求值算法：

1. *自求值(self-evaluation)* ：若被求值的表达式不是*符号(symbol)* 或不是非空列表，则求值结果为自身。
2. 名称解析：若被求值的表达式是一个符号，则这个符号被视为*变量名(variable name)* ，求值结果为该符号在上下文（当前环境确定的词法作用域）中变量绑定确定的对象。
3. 否则，被求值的表达式是一个非空列表，则：
	1. 若第一个子表达式是空表（这里不需要是字面上的语法表示 `()` ），则移除；
	2. 对第一个子表达式求值；
	3. 把第一个子表达式求值的结果作为*操作符(operator)* ，以其余子表达式作为操作数，求值*合并(combination)* 。

　　被作为操作符的值应是合并子右值或引用合并子对象的左值，求值合并的作用是调用对应的合并子；否则，求值失败，引起错误。

## 函数(function)

　　成功调用合并子的表达式是*函数调用(function call)* 表达式*。在最终调用合并子的操作符位置的求值为合并子左值或右值的非列表表达式是*函数* 。

　　函数是合并子右值、合并子左值（引用值）或求值为这些值的符号。

　　合并子调用的结果是函数调用的结果，称为*函数值(function value)* 。

　　特定的函数总是用来创建特定类型值的对象（右值）。这类函数是（特定类型值的）*构造器(constructor)* 。

## 中缀变换函数

　　中缀变换的 <transformed-infix> 在被求值时在操作符的位置，起到函数的作用。

　　以下中缀记号中缀变换函数的调用具有以下语义：

* `;` 求值同标准库函数 `$sequence` 。
* `,` 求值同标准库函数 `list` ，但保留引用值。

## 一等(first-class) 实体

　　程序引入或可被程序操作的 Unilang 实体在基础语言中是一等实体。一等实体总是可被作为操作数调用函数。

　　若一等实体是对象，它是一等对象。

　　相较于其它语言，基础语言不附加限制区分非一等的实体。这有利于同时提升简单性和一致性。区分一等对象和一等实体并不是限制，

　　本文档和派生实现的语言规则可能引用其它的非一等对象。

　　特别地，环境是一等实体；程序可在基础语言中指定不同的环境进行求值。但为可用性，环境的绑定和父环境这些状态都不是直接的一等实体。访问环境对象时，它们不被环境对象的同一性影响，而是共享的。

　　为灵活控制对象所有权，避免循环引用且允许检查误用，一等环境可能对上述共享的资源实体具有所有权。大部分情况一等环境是共享环境状态的*弱引用(weak reference)* ，不具有所有权；其它情形一等环境对环境状态具有共享的所有权。

　　此外，为满足环境的*稳定性(stability)* 即其中变量绑定不可变，可通过附加的检查机制限制绑定修改。稳定的环境可作为其它环境的父环境，称为*隐藏环境(hidden environment)* 。隐藏环境可被名称解析利用，但不能被直接访问，而不是一等对象。

# 标准库

　　基础语言提供标准库，作为语言扩展和应用程序的基础。

　　标准库以具名的实体的方式，在*基础环境(ground environment)* 提供绑定，作为程序应用程序的编程接口。
　
　　基础语言的实现中，初始环境以基础环境作为父环境。基础环境在此是隐藏环境，确保程序执行时不改变基础环境中的绑定。

## 操作文法约定

　　描述操作的元语言使用以下语法：

* `...` Kleene 星号，重复之前修饰的项 0 次或多次。
* `+`  重复之前修饰的项 1 次或多次。
* `?`  重复之前修饰的项 0 次或 1 次。

　　实体元素使用以 `<>` 包含的格式。注意基础语言中仍可出现同名的标识符，但此处不按标识符解释。

　　未求值的操作数：

* `<symbol>` 符号。
* `<eformal>` 表示可选提供的环境名称或 `#ignore` 的符号。使用和 <symbol> 相同的表示。通常为动态环境。
* `<expression>` 待求值的表达式。
* `<expressions>` 形式为 `<expression>...` 的待求值形式。
	* 求值时被作为单一表达式，代替 `<expression>` 可避免语法中要求谁过多的括号及 `eval` 等求值形式中显式构造列表的需要。
* `<binding>` 绑定列表，形式为 <symbol> <expressions> ，用于指定被求值的表达式和绑定参数的符号。
* `<bindings>` 元素为 <binding> 的列表，形式为 (<binding>...) 。
* `<body>` 出现在元素的末尾 `<expressions>?` 形式，用于函数体等替换求值的目标。
* `<expression-sequence>` ：同 `<body>` 但蕴含顺序求值。
* `<consequent>` 同 `<expression>` 仅用于 `<test>` 求值为 `#t` 时。
* `<alternate>` 同 `<expression>` ，仅用于 `<test>` 求值不为 `#t` 时。
* `<definiend>` 被绑定项的目标，是包含符号的有向无环图表达式。
* `<formals>` 形式参数形式。同 `<definiend>` 但允许派生实现定义更多检查。
* `<clauses>` 元素为条件分支的列表，形式为 `(<test> <body>)...` 。
* `<variable>` 变量。用于表示被定义的名称。同 `<symbol>` ，其中的处理与作为非列表的 `<formals>` 相同。

　　求值得到的操作数：

* `<object>` 一般对象，包括引用对象的引用值。
* `<reference>` 对象引用值。
* `<list>` 列表。
* `<lists>` 元素都是列表的列表。
* `<bool>` 布尔值，值为 `#t` 或 `#f` 的集合。
* `<test>` 类似 `<object>` ，通常预期为 `<bool>` ，作为条件。
* `<combiner>` 合并子。
* `<applicative>` 应用子。
* `<predicate>` 谓词，是应用操作数的求值结果的值为 `<bool>` 的 `<applicative>` 。
* `<environment>` 一等环境。

　　操作数名称后可添加整数以区分不同的实际参数。

## 操作名称约定

　　对应合并子是操作子的函数以 `$` 起始。

　　作为谓词的函数名以 `?` 结尾。

　　为改变对象而直接（而不是通过指定参数求值）蕴含副作用函数名以 `!` 结尾。

　　这些约定对标准库函数有效，用户程序不被要求。

## 操作数约定

　　若函数是构造器，则操作数中的参数求值后发生左值到右值转换。这减少悬空引用的可能性。

## 基本操作和核心库

　　基本操作和核心库在基础环境中直接提供绑定。

　　核心库提供对象 `ignore` ，其值为符号 `#ignore` ，在特定操作中表示被忽略的值。

　　其它接口提供为函数，包括：

`$if <test> <consequent> <alternate>`

　　条件分支，按条件成立与否返回 `<consequent>` 或 `<alternative>` 之一，可能是引用值。

`$if <test> <consequent>`

　　省略第三操作数的条件分支，条件成立时返回 `<consequent>` 。若<test> 求值为 #f ，则结果为 `#inert` 。

`null? <object>`

　　判断操作数是否为空列表。

`cons <object> <list>`

　　构造两个元素的列表。

　　因为不支持列表中存在环，因此第二个操作数应为列表，否则引起错误。

`eval <expression> <environment>`

　　在参数指定的环境中求值，结果作为函数值。

`lock-environment <environment>`

　　锁定环境：创建环境强引用。

　　检查操作数的环境若引用，结果为对应的环境强引用。

　　强引用可能引起环境之间的不被检查的循环引用，用户应自行避免未定义行为。

`make-environment <environment>...`

　　创建以参数为父环境的环境。

　　创建的环境是强引用。

`$def! <definiend> <expressions>`

　　修改当前环境中的绑定。

　　类似 <formals> ，<definiend> 支持递归匹配。

`$vau/e <environment> <formals> <eformal> <body>`

　　创建指定静态环境的 vau 抽象（关于 vau 抽象，参见 [Shu10] ）。

　　创建的抽象是 <eformals> 求值后的环境为*静态环境(static environment)* 的操作子。静态环境是用于创建调用时的新环境的父环境。

　　<environment> 是指定*动态环境(dynamic environment)* 的表达式，应为符号。动态环境是发生调用处的当前环境。

　　<formals> 是指定*形式参数(formal parameter)* 表达式，应为以符号为非分支节点的有向无环图。由于不支持引用值，实际上是树，非分支节点是树的叶节点，分支节点是列表。

　　<formals> 被用于在合并子调用时匹配实际参数，参数匹配算法如下：

* 初始化 <formals> 为当前形式参数，函数合并（包括作为合并子的第一个子项和作为操作数的之后余下的子项）作为当前实际参数。
* 对每一对当前形式参数和当前实际参数，比较两者（任一者是引用值的，视为匹配被引用对象，下同）：
	* 若两者都是列表，则：
		* 若形式参数列表元素的末尾元素不是符号也不是列表，则参数匹配失败。
		* 若形式参数列表元素的末尾元素是以 `.` 起始的符号，则存在*省略(ellipsis)* ；保存移除 `.` 的符号，并从子项中移除末尾元素，继续进行比较。
		* 若形式参数和实际参数的列表元素数相等，或存在省略时移除末尾元素后的形式参数元素数不大于实际参数的元素数，则：
			* 除被保存的省略的元素外，以深度优先搜索从左到右逐一递归匹配两者的元素。
			* 对省略的元素，若保存移除 `.` 的符号非空，创建一个列表对象保存匹配的实际参数中的零个或多个对象，绑定到以保存的符号作为名称的变量。
			* 否则，所在的形式参数列表的末尾元素是 `.` ，忽略实际参数，不绑定对象。
		* 否则，若不存在省略，列表的元素数不相等，参数匹配失败。
		* 否则，实际参数的列表元素不足，参数匹配失败。
	* 若形式参数不是符号，则参数匹配失败。
	* 若形式参数是不等于 `#ignore` 的符号，则绑定实际参数到以符号作为名称的变量。
	* 否则，忽略实际参数，不绑定对象。

　　当前不检查匹配的符号是否已经被绑定，形式参数树中重复的符号引起绑定的作用未指定。

　　创建的抽象作为操作子，被调用时：

* 保存当前环境作为动态环境。
* 创建环境*守卫(guard)* 保存当前环境，之后不论调用成功或出错都会回滚保存的环境。
* 创建新的环境，并以这个新环境作为当前环境。
* 若 <eformal> 是不等于 `#ignore` 的符号则绑定动态环境（先前的当前环境）到这个以符号作为名称的变量。
* 设置操作子保存的静态环境为当前环境的父环境。
* 匹配实际参数。成功匹配时，其中绑定的对象初始化环境中的变量绑定。
* 在当前环境中以函数体 (<body>) 中的表达式的副本作为*求值结构(evaluation structure)* 进行求值。

　　类似 `$vau` ，但支持额外的求值环境作为静态环境。

　　因为支持保存环境的所有权，`$vau/e` 被设计为比 `$vau` 更基本的操作。

　　不考虑所有权时，`eval` 和 `$vau` 可派生 $vau/e 。

`wrap <combiner>`

　　包装合并子为应用子。

`unwrap <applicative>`

　　解包装应用子为底层的合并子。

`raise-invalid-syntax-error` <string>

　　引起包含参数指定的字符串内容的语法错误。

`() get-current-environment`

　　取当前环境：取当前环境的环境弱引用。

`() lock-current-environment`

　　锁定当前环境：取当前环境的环境强引用。

`$vau <formals> <eformal> <body>`

　　创建 vau 抽象。

　　类似 `$vau/e` ，但以当前环境代替额外的求值环境作为静态环境。

$lambda <formals> <body>`

　　创建 λ 抽象 。

　　和创建 vau 抽象类似，但创建的是调用时对操作数的元素求值一次的应用子，且忽略动态环境。

　　表达式项的用法和 vau 抽象类似。

`list <object>...`

　　创建列表（类型为 `<list>` ）对象。

`$set! <environment> <formals> <expressions>`

　　修改指定环境的变量绑定。

　　在当前环境求值 `<environment>` 和 `<expressions>` ，再以后者的求值结果修改前者的求值结果指定的环境中的绑定。绑定效果同使用 $def! 。

`$defv! <variable> <formals> <eformal> <body>`

　　绑定 vau 抽象，等价 `$def! <variable> $vau <formals> <eformal> <body>` 。

`$defl! <variable> <formals> <body>`

　　绑定 λ 抽象，等价 `$def! <variable> $lambda <formals> <body>` 。

`() make-standard-environment`

　　创建标准环境：创建基础环境绑定外没有其它绑定的环境。

　　基础环境是新创建环境的唯一父环境。

`$sequence <expression-sequence>`

　　顺序求值。操作数非空时结果是最后的参数，可能是引用值；否则结果是 `#inert` 。

　　求值每个 <object> 的副作用包括其中临时对象的销毁都被顺序限制。

`first <list>`

　　取列表第一个元素的值。

`rest <list>`

　　取列表第一个元素以外的元素值构成的列表。

`apply <applicative> <object> <environment>`

　　在指定环境中应用。

　　同求值 `eval (cons () (cons (unwrap <applicative>) <object>)) <environment>` 。

`apply <applicative> <object>`

　　在新建的空环境中应用。

　　同求值 `eval (cons () (cons (unwrap <applicative>) <object>)) (() make-environment)` 。

　　以上 apply 的函数值保留引用值。

`list* <object>+`

　　在列表前附加元素创建列表。

　　类似 `cons` ，但支持一个和多个操作数。

　　对一个操作数的情形返回原值，否则类似 `cons` ，检查最后一个实际参数是 <list> 。

`$defw! <variable> <formals> <eformal> <body>`

　　绑定 `wrap` 的 vau 抽象，等价 `$def! <variable> wrap ($vau <formals> <eformal> <body>)` 。

`accr <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3>`

　　在抽象列表的元素上应用右结合的二元操作。

　　对 <object1> 指定的抽象列表进行处理，取得部分和。

　　当谓词 <predicate> 成立时结果为参数指定的对象，否则继续处理抽象列表中余下的元素。

　　处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。

`foldr1 <applicative> <object> <list>`

　　同 `accr` ，但指定谓词为 `null?` ，应用子分别为 `first` 和 `rest` 。

`map1 <applicative> <list>`

　　单列表映射操作，使用指定应用子对列表中每个参数进行调用，结果为调用结果的列表。

　　任意两个调用之间的相对求值顺序未指定。

`list-concat <list1> <list2>`

　　取顺序连接的列表。

`append <list>...`

　　顺序拼接列表。

`$let <bindings> <body>`

　　局部绑定求值。

`$let/d <bindings> <eformal> <body>`

　　同 `$let` ，但在 <body> 的求值前引入绑定到动态环境的变量 <eformal> 。

　　若 <eformal> 为 `#ignore` ，作用同 `$let` 。

`$let* <bindings> <body>`

　　顺序局部绑定求值。

　　同 `$let` ，但 <bindings> 中的被用于绑定的表达式从左到右顺序求值，被用于初始化变量的表达式在求值时可访问 <bindings> 中之前绑定的符号。

`$letrec <bindings> <body>`

　　顺序局部绑定求值，允许递归引用绑定。

`display <object>`

　　输出对象的*外部表示(external represetntation)* 。

* 对列表，输出的表示是以 `(` 和 `)` 作为边界，元素以单个 ` ` 为分隔符的序列，其中的元素被递归地嵌套输出。
* 对非列表的存在对应字面量的值，输出这个值的字面量形式。
* 对引用值，输出被引用对象。
* 其它值的外部表示未指定。

`() newline`

　　输出换行。

