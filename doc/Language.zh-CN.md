# 前言(Foreword)

　　本文档是 Unilang 语言的设计规格说明。

## 体例说明

　　本文档中的特定文本（主要用于源代码）使用 `引用文本` 指定。非引用的正常文本适用以下体例。

　　局部的 *术语(terms)* 和 **强调** 的文本以特定的不同于其它正文的格式显示。

　　标记为 **注释** 的文本属于*说明性(informative)* 而不是*正式(normative)* 规则。

　　外部文档引用和内部章节引用以[超链接](https://zh.wikipedia.org/zh-cn/%E8%B6%85%E9%93%BE%E6%8E%A5)指定。全文外部引用另见以下的正式引用(normative references) 章节。

　　部分术语或其它名词性文本的特定义项首次出现时使用半角括号标注对应的英文翻译供参照。首字母缩略语(acronym) 和非局部概念的标题使用翻译时，词首字母大写。

　　本文档指定的语言规则(language rule) 中的形式文法(formal grammar) 包括形式语法(formal syntax) 和特定操作的形式，不提供附加的形式语义(formal semantic) 。

　　形式语法的语法类别(syntax category) 以 [BNF](https://zh.wikipedia.org/zh-cn/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F) 推导规则表示。

# 绪论(Introduction)

　　Unilang 是一门现代的、模块化的、可移植的和可扩展的通用目的编程语言。

　　Unilang 提供*基础语言(base language)* 和*语言扩展(language extension)* 。基础语言指定基本的语言规则；语言扩展在基础语言之上提供附加的规则，补充或改变语言的特定特性，提供比基础语言更多的实用功能。

## 范围(Scope)

　　本文档描述一个*符合(conforming)* *要求(requirements)* 的基础语言实现需要遵循的规则，这蕴含语言提供的*特性(feature)* 。这些语言特性主要是功能特性；其它的特性通常由语言的实现保证，而不影响*符合性(conformance)*。

　　在基础语言上附加语言扩展得到的*派生语言实现(derivative language implementation)* 可具有不同的语言规则，但应满足本文档中的最小要求以维持符合性。

　　派生语言实现是语言的设计，是抽象的实现。基础语言和派生语言实现都可能有非语言设计形式的具体实现（例如*解释器(interpreter)* ）。不致混淆时，派生语言实现简称*派生实现(derived implementation)* 。一般地，Unilang 语言的*实现(implementation)* 指非语言设计形式的具体实现以及基础语言的派生实现。

　　除非另行指定(specified otherwise) ，本文档的语言规则同时适用于基础语言和派生实现。

## 正式引用

　　本章引用本文档使用的外部参考(external reference) ，包含不被局部术语涵盖的一般解释。包括：

* ISO/IEC 2382 (all parts), Information technology — Vocabulary
* ISO/IEC 14882:2017, Information technology — Programming languages — C++
* [Fexprs as the basis of Lisp function application or $vau : the ultimate abstraction](http://www.wpi.edu/Pubs/ETD/Available/etd-090110-124904/unrestricted/jshutt.pdf) ([Shu10])

* [ISO C++] ISO/IEC 14882
* [ISO 2382] ISO/IEC 2382

# 术语和定义(Terms and Definitions)

* **行为(behavior)** 语言实现或在满足符合性的具体语言实现中的程序的外部表现。
* **程序(program)** 具体语言实现接受的以代码表示的输入，或被变换后对应的输出。
	* 语言实现支持运行*程序(program)* 。除非另行指定，程序指符合本文档要求的 Unilang 代码的输入程序，即 Unilang *源程序(source program)* 。
**诊断(diagnostics)** 明确的对特定预期或非预期执行的行为的响应的总和。
**诊断消息(diagnostic message)** 用于和用户交互的表现诊断的告知及提示。
**未定义的(undefined)** 可能导致违反语言规范的约束但语言规范同时没有要求提供任何可能影响符合性的保证（如具有诊断消息）的。
	* 表示置于语言规则下的行为等不可预测。
**未指定的(unspecified)** 在各个实现中可能存在的，通常允许多种不同的实现选项。
	* 不应假定不同实现在明确未指定的规则上表现一致。
**由实现定义的(implementation-defined)** 取决于各个具体语言实现的，要求有文档说明。
**由派生实现定义的(derived-implementation-defined)** 取决于各个具体派生实现的，要求除存在默认定义或被派生实现的部分有明确的文档说明。
**未定义行为(undefined behavior)** 未定义的行为。
**未指定行为(unspecified behavior)** 未指定的行为，由实现选取规格中可能允许的指定行为的不确定选项，后者可能由显式或隐式的语言规则确定。

# 计算模型

　　本文档的 Unilang 语义规则以*抽象机(abstract machine)* 的形式提供。抽象机可具有*可变状态(mutable state)* 。

　　Unilang 程序的*执行(execution)* 可包括不同的*计算作用(computational effect)* ，包括：

* 确定一个作为计算结果的*值(value)* 。
* 改变抽象机中的可变状态。

　　后者称为*副作用(side effect)* ，包括：

* 特定的对象访问：改变抽象机中的可被程序*访问(access)* 的可变状态。
* *控制作用(control effect)* ：改变之后会被执行的程序。

　　派生实现可定义其它的作用。

　　除非另行指定，副作用构成实现接受程序时具有的*可观察(observable) 行为*。

# 符合性(Conformance)

　　本文档指定 Unilang 程序的语言规则，包括语法和语义规则，以及实现环境应提供的程序接口。

　　Unilang 的实现翻译程序到适当的目标代码的形式。翻译的输入是源程序。翻译的直接输出可能是外部环境不可见的，即*解释(interpret)* ；也可以是确定具体形式的，即*编译(compile)* 。

　　一个符合本文档的实现应支持能接受符合规则的程序作为翻译的输入，并按本文档约定的规则中的要求表现计算作用影响的行为。

　　特定的程序是 AOT(ahead-of-time) 翻译的，翻译总在执行时的余下阶段之前进行，余下的阶段运行程序。基础语言是否使用 AOT 翻译实现未指定。

　　若程序具有未定义行为，则对实现没有任何要求，包括是否接受源程序的判定。

## 诊断(Diagnostics)

　　Unilang 要求具体实现对不满足语言规则约束的特定情形给出诊断。这类规则是*可诊断的(diagnostable)* 。

　　本文档中，*引起(signal)* 指定为*错误(error)* 的条件明确要求诊断。

　　违反语法规则的的情形是错误。

　　程序的语法性质和部分语义性质在翻译时检查，通过检查则应接受翻译，否则应提供诊断。

　　一次翻译接受的源代码是一个*翻译单元(translation unit)* 。对语法规则的检查以不大于翻译单元的单位整体进行。对未通过语法规则检查的诊断应至少能明确区分具体失败的翻译单元。

　　对象操作可能进行*检查(check)* 。检查失败引起错误。

## 最小符合性要求

　　Unilang 具体实现应满足以下最小符合性要求：

* 以翻译单元为单位进行翻译，满足：
	* 翻译接受*合式的(well-formed)* ，即符合语法规则和可诊断语义规则的程序。
	* 对*不合式的(ill-formed)* 程序，若不存在未定义行为，则要求翻译提供诊断消息并拒绝接受程序而终止程序的运行。（对 AOT 翻译实现，则直接终止翻译。）
* 对合式的程序，具体实现的行为符合抽象机语义蕴含的可观察行为。

　　注意可观察行为以外的具体实现行为和抽象机的行为的一致性未指定。这允许*优化的(optimimal)* 实现省略不影响可观察行为的计算作用。

# 词法规则(Lexical Rules)

　　Unilang 基础语言以空白符作为翻译单元中*词素(lexeme)* 的间隔。识别词素后，每个词素按照构成字符的不同，被分为不同的*记号(token)* 类别。

　　记号类别包含*标点(punctuator)* 、*字面量(literal)* 和*标识符(identifier)* 。

　　基础语言识别的标点包括 `(` 和 `)` 。

　　字面量包括：

* 以 `"` 作为词素起始和结尾的*字符串字面量(string literal)* 。
* 以 0~9 组成的十进制整数数值字面量。
* `#t` 和 `#f` 表示逻辑真和逻辑假。
* `#inert` 指定特定操作中表示被忽略的结果。

　　派生实现可在此之外定义其它记号类型和扩展的标点，后者应符合 C++ ([ISO C++]) 的定义。

　　派生实现也可定义*预处理(preprocessing)* 过程翻译其它表示为包含 Unilang 基础语言接受的词法形式的翻译单元。

# 语法

　　Unilang 基础语言的语法以基本语法和可通过前置预处理实现的*中缀变换(infix transformation)* 规则定义。

## 基本语法

```
<expression> ::= <atom-expression> | <composite-expression> | <list-expression>
<composite-expression> ::= <token-expression> | <expression-token>
<atom-expression> ::= <token>
<list-expression> ::= <left-list-bound> <expression>* <right-list-bound>
<left-list-bound> ::= `(` | <extended-left-list-bound>
<right-list-bound> ::= `)` | <extended-right-list-bound>
```

　　Unilang 基础语言的翻译单元以*表达式(expression)* 作为语法单位。一个表达式可以是：

* 不可拆分为其它表达式的*原子表达式(atom expression)* 。
* 由派生实现定义的，记号和其它表达式直接*并置连接(juxtaposition)* ，之间没有其它记号的表达式。
* 由分隔符作为边界的包含若干个*子表达式(subexpression)* 的*列表表达式(list expression)* 。

　　原子表达式在词法上是一个记号。

　　以下词法构造在基础语言中是空集，可由派生实现定义：

* `<extended-left-list-bound>`
* `<extended-right-list-bound>`
* `<token-expression>`
* `<expression-token>`

## 中缀变换

　　中缀变换替换形如 <expression> (<infix> <expression>)* 的记号序列为 <transformed-infix> <expression>+ 形式的记号序列。

　　其中，基础语言支持的中缀记号 <infix> 是 `;` 或 `,` ，而 <transformed-infix> 是语法不可见的中缀变换函数。

　　变换的不同 <expression> 的实例以相同的词法顺序在变换后的结果中被保存。

　　变换后的结果符合以上的基本语法规则。

# 语义

## 实体模型

　　Unilang 的程序操作*实体(entity)* 。

### 对象和值

　　区分*同一性(identity)* 的实体是*对象(object)*。同一性决定语言的不同表达式可以描述的相同的对象。

　　不区分同一性的特定的实体是*值(value)* 。值可以具有*类型(type)* 以明确*外延(extension)*（一般建模为集合）。

### 可变性

　　对象可能具有*可变(mutable)* 状态，是可变的对象；对象也可能总是具有一种不被预言分辨的状态，是*不可变(immutable)* 的。其它实体是不可变的。

　　可变对象允许*改变(mutate)* 使对象具有不同的状态。

　　语言实现可定义其它的机制明确同一性或外延的其它实体。

### 实体的类型

　　类型是一种值，其外延是类型*全集(universe)* 。

　　除非另行指定，不相同的类型的值之间不相等。

### 实体的值

　　对象总是关联特定*类型(type)* 的值作为它的内容，称为对象的值。

　　对象的值是对象的状态的一部分。对象的值的不可变性蕴含对象的不可变性，但反之不保证。这允许实现在对象中保存不影响值但仍可影响可观察行为的状态（例如同步需要的锁定状态）。

　　因为明确同一性，特定的对象实例总是可被*创建(create)* 或*销毁(destroy)* ，且可能影响可观察行为。

　　类似地，不明确同一性的一般实体可具有关联的值，但不保证作为其状态的一部分。

### 初始化

　　若实体关联值，初始化确定其的初始值。

　　创建对象时通过初始化确定对象的值。

　　初始化可使创建的对象作为其它对象的副本，这种初始化称为*复制初始化(copy initialization)* ；此时，其它对象的值不一定保持不变。其它实体的初始化称为*直接初始化(direct initalization)* 。

### 对象的存储期和生存期

　　程序执行时，对象占据存储资源，具有存储期。每个被创建后和销毁前的对象具有一段连续的*生存期(lifetime)* 。生存期是存储期的子集。

**注释** 这和 [ISO C++] 的对象的对应性质相同。

　　确定对象的值或改变对象的值访问对象。

　　在生存期外访问对象是受限的；除非另行指定，在生存期外访问对象的程序具有未定义行为。

### 内存安全

　　*内存安全(memory safety)* 是存储资源避免特定类型不可预测错误使用的性质。

　　基本的内存安全保证蕴含非并发访问时不引起未定义行为。这至少满足：

* 对对象占据的存储的访问总是在提供存储的对象的存储期内；
* 不访问对象的未被初始化的值。

　　特定的操作保证内存安全。

**注释** 内存安全不包含并发访问安全。当前语言不提供避免并发访问时可能具有数据竞争的机制。

**注释** 和宿主实现的互操作可能影响内存安全保证的实现。

### 对象的所有权和子对象

　　一个或多个对象可具有另一个对象的*所有权(ownership)* ：前者约束后者的创建和销毁的时机。被所有的对象的生存期是所有者的生存期的并集的子集。

　　一个对象可以具有若干个*子对象(subobject)* ，在创建后创建子对象，在销毁前销毁子对象，而具有子对象的所有权。

　　类似地，对象可以对内部的非一等对象的资源实体具有所有权。

　　所有权作为实体上的二元关系，满足反自反、反对称和传递性。

### 对象的其它元数据

　　除以上性质外，对象可关联其它元数据以指定对象的属性种。不在语言中要求直接可被访问的实体统称为标签(tag) 。

　　对象具有的标签决定以下正交的性质：

* 唯一(unique) 引用：指定对象的值关联到自身以外的不被其它对象*别名(aliasing)* 的对象。以唯一引用关联的对象进行复制初始化时，不需要保留关联的对象的值。
* 不可修改(nonmodifying) ：指定对象的值保持不变（类似 [ISO C++] 的 `const` 类型的值）。若操作需要修改此对象，则引起错误。
* 临时(temporary) 对象：指定对象的值被临时使用。类似唯一引用，但限定的是对象自身而非关联的其它对象。

## 表达式的值和值类别

　　表达式通过*求值(evaluation)* 进行计算并体现计算作用，其中可确定表达式的计算结果作为关联的值，即表达式的值。

　　在语法规则之上，基础语言约定可能*未求值的(unevaluated)* 表达式作为对象也具有值。未求值的表达式满足以下性质：

* 作为记号的标识符是*符号(symbol)* ，是符号类型的值。
* 列表表达式中若不含有子表达式，则这个表达式是空列表；否则，是非空列表。

　　空列表和非空列表统称列表，其中包含的子对象是列表的元素。未求值的非空列表中，子表达式是列表的元素。

　　Unilang 的列表是*真列表(proper list)* ：列表的元素有限，同一个列表的不同元素之间不具有相互的所有权，生存期不相交。

　　特定的值是*引用值(reference value)* ，具有引用类型。引用值关联到*被引用对象(referent)* 。

　　具有引用值的表达式是*左值(lvalue)* ，否则是*右值(rvalue)* 。左值和右值统称表达式的*值类别(value category)* 。

　　引用类型和其它对象的类型不同。但除非另行指定，访问引用值总是等价于访问其被引用对象，这称为*左值到右值转换(lvalue-to-rvalue conversion)* 。例外而不进行这种转换的上下文中，引用值被保留。

　　引用值可以是唯一引用或引用临时对象的值，两者都是*右值引用(rvalue reference)* ；否则，引用值是左值引用。非引用值的唯一引用标签被忽略。唯一引用作为右值时是*消亡值(xvalue)*；其它右值是*纯右值(prvalue)* 。消亡值和左值统称为*泛左值(glvalue)*。

　　具体表达式的值类别由本文档约定的求值算法和具体操作确定。

**注释** 值类别、左值引用、右值引用及左值到右值转换和 [ISO C++] 的同名特性类似，后者实际上转换泛左值到右值。其中，临时对象类似 [ISO C++] 中延长对象生存期的引用，而唯一引用类似 [ISO C++] 中其它情形的右值引用。和 [ISO C++] 不同，引用值的被引用对象是一等对象，可能仍是引用值，这种转换的结果并非保证纯右值。唯一引用类似 [ISO C++] 的右值引用。

### 引用值和初始化

　　引用值可使用被引用对象作为初值进行直接初始化。

　　初值是引用值时，初始化的引用值的被引用对象可能是初值的被引用对象，这种情形称为*引用折叠(reference collapse)* 。其它情形初始化的引用值的被引用对象是初值。是否引用折叠依初始化发生的具体上下文而定。引用折叠的结果是唯一引用的一个必要条件是被引用对象是右值引用。

**注释** 引用折叠类似 [ISO C++] 的同名特性操作。但与 C++ 不同，引用值是一等对象，在某些保留引用值的实现相关的上下文中，被引用对象允许不发生引用折叠而直接使初始化的引用的被引用对象是引用值。

　　为支持引用值作为一等对象，在左值到右值转换的基础上定义更精细的引用值提升转换，即以下转换操作：

* 若操作数是引用值，则结果是操作数引用的被引用对象；
* 否则，结果是操作数。

**注释** 根据引用值的性质，若操作数是已被折叠的引用值，则引用值提升转换等价左值到右值转换；否则，有限次的引用值提升转换等价左值到右值转换。

　　程序在一些需要引用的被引用对象的上下文中使用返回值转换：一次引用值提升转换和可选的临时对象实质化转换的复合。

**注释** 实现可消除引用值而避免创建冗余对象的开销。

　　程序执行时引入循环引用的程序具有未定义行为。

　　临时对象可直接初始化引用值。和非临时对象的引用值不同，临时对象初始化的引用值和关联的被引用对象之间不需要区分同一性，因此使用被引用对象添加临时对象标签表示。

　　从纯右值初始化临时对象作为消亡值，称为*临时对象实质化转换(temporary materialization conversion)* 。

**注释** 这类似 [ISO C++] 引入临时对象的相同特性。

　　可转移(movable) 的对象通过以下规则确定：

* 非引用值的对象总是可转移的。
* 引用值关联的被引用对象可能是可转移的：
	* 若引用值具有的标签是被引用对象的唯一引用且非不可修改，被引用对象是可转移的。
	* 若引用值由临时对象初始化，被引用对象（即此临时对象）是可转移的。

　　若满足上述可转移对象条件的对象通过复制初始化创建对象副本，则对象被转移，被转移的对象的值在转移后未指定；否则，对象被复制，被复制的对象在复制后的值保持不变。

　　被转移后的对象具有*有效但未指定(valid but unspecified)* 的值。

**注释** 这和 [ISO C++] 相同。

## 变量和环境

　　*变量(variable)* 是具有*名称(name)* 的实体，参见 [ISO 2382]。

　　变量是在*环境(environment)* 对象中存储的*绑定(binding)* 的集合，即名称到实体的映射。

　　环境对象对其中的变量绑定中的对象具有所有权。

　　语言中的环境以*环境引用(environment reference)* 的形式作为[一等对象](#一等实体)。环境对象自身在语言中不可见，必须通过环境引用访问。

**注释** 环境引用不是[引用值](#表达式的值和值类别)。后者关联的被引用对象是一等对象。

　　环境对象可能被环境共享。一个环境引用可能是*强引用(strong reference)* 或*弱引用(weak reference)* 之一。关联到相同的环境对象的环境强引用对关联的环境对象具有共享的[所有权](#对象的所有权和子对象)。

　　一个环境是*空环境(empty environment)* ，当且仅当其中的绑定是空集。

　　*新环境(fresh environment)* 是新创建的环境。除非另行指定，新环境是不存在能引起程序行为改变的父环境的空环境。

　　环境可以具有零个或有限多个父环境。环境的父环境在创建时指定，之后不可变。

　　给定一个名称，在环境中确定被名称指称的对象，称为*名称解析(name resolution)* 。

　　基础语言使用以下名称解析算法：

1. 若在指定的环境中存在指定的名称对应的绑定，绑定的对象是名称查找的结果对象。
2. 否则，按创建环境时指定的顺序，深度优先搜索父环境中的绑定，搜索到的第一个确定对应的绑定的对象是名称查找的结果对象。
3. 否则，名称解析失败，引起错误。

　　成功的解析确定的对象以引用这个对象的引用值表示。

　　名称解析的深度优先搜索规则支持*词法作用域(lexical scoping)* 和*名称隐藏(name hiding)* 的实现。

　　求值 Unilang 表达式时总应存在一个环境，称为*当前环境(current environment)* ，作为名称解析算法的初始输入。

　　语言实现为程序开始运行时的具有的当前环境称为*初始环境(initial environment)* 。

　　部分名称是*保留名称(reserved name)* ：含有 `$$` 的名称保留给宿主交互使用；含有 `__` 的名称保留给语言实现。若程序的源代码中的保留名称被作为变量名解析，程序的行为未定义。

## 间接值

　　引用值和环境引用统称间接值(indirect value) 。间接值关联和自身不同一的对象：引用值的被引用对象，和环境引用的环境对象。

　　间接值关联的对象通过间接值访问。

　　间接值有效当且仅当存在关联的对象且访问对象不引起未定义行为。其它间接值是无效的。

　　有效的引用值可能被*无效化(invalidate)* 。因关联的对象存储期结束而被无效化的是*悬空(dangling)* 间接值。

　　访问时，关联的对象的生存期未结束，否则非[内存安全](#内存安全)。

## 合并子

　　*合并子(combiner)* 是在特定表达式中出现的可被求值时*调用(invoke)* 的对象。

　　合并子的调用接受*操作数(operand)* 实体。一般地，操作数作为一个对象，可具有树型结构，即*操作数树(operand tree)* 。操作数树的子节点构成一个序列，其中每个子对象的值在调用时可作为*实际参数(actual argument)* ，进行计算。操作数可以是一个操作数树的子节点或连续的子节点序列。

　　合并子分为两类：

* 调用时总是先对操作数树中的每个直接子节点（即每个确定实际参数的操作数子对象）求值，然后调用*底层(underlying)* 合并子。这种合并子是*应用合并子(applicative combiner)* 简称*应用子(applicative)* 。
* 否则，合并子是*操作合并子(operative combiner)* ，简称*操作子(operative)* 。

　　应用子的底层合并子可以是其它应用子，即确定实际参数的求值可能发生多次。

　　操作子调用匹配参数，可要求操作数符合一定的结构，否则参数不匹配。参数不匹配引起错误。

　　匹配参数后的操作子调用的具体行为由具体合并子对象确定。这可在创建合并子对象时决定。

　　合并子通过程序内的合并子的定义或其它另行指定的方式在外部引入。

　　在程序中定义的合并子提供指定*约束变量(bound variable)* 的*形式参数(parameter parameter)* 和指定确定变量后的其它作用的*求值结构(evaluation structure)* 。形式参数可以是符号、空列表及其复合的表达式树，统称为*形式参数树(formal parameter tree)* 。

　　一个存在形式参数的合并子被调用时，确定实际参数是否匹配形式参数树：确定实际参数和形式参数树中的对应位置的子表达式对应。若存在任一实际参数不对应，则参数不匹配。成功确定对应的形式参数树中的子表达式若为符号，则作为变量名，在特定的上下文中创建变量绑定，作为形式参数。绑定的实际参数和对应的形式参数作为不同的实体时，发生*参数传递(parameter passing)* 。参数传递使形式参数具有作为实际参数值的副本。参数传递可能使和实际参数相关的资源被复制或转移。

　　一个存在求值结构的合并子被调用、所有的参数都匹配成功且参数传递成功后，（参数传递确定的）形式参数的值替换求值结构中的副本中和形式参数树的子表达式相同的符号。

　　合并子的*正常(normal)* 调用总是可确定一个计算结果，作为求值的结果。除非另行指定，若求值结果为引用值，则*提升(lift)* 为被引用对象的值。这避免返回*悬空引用(danling reference)* 。

　　合并子的*非正常(abnormal)* 调用不确保调用结果。

　　非正常调用的控制被转移到需要调用的求值表达式之外，这可以发生在引起错误时。

　　关于合并子的形式理论，参见 [Shu10] 。

## 求值算法

　　基础语言使用以下统一的求值算法：

1. *自求值(self-evaluation)* ：若被求值的表达式不是符号或不是非空列表，则求值结果为自身。
2. 名称解析：若被求值的表达式是一个符号，则这个符号被视为*变量名(variable name)* ，求值结果为该符号在上下文（当前环境确定的词法作用域）中变量绑定确定的对象的经引用折叠的引用值。
3. 否则，被求值的表达式是一个非空列表，则：
	1. 若第一个子表达式是空表（这里不需要是字面上的语法表示 `()` ），则移除；
	2. 对第一个子表达式求值；
	3. 把第一个子表达式求值的结果作为*操作符(operator)* ，以其余子表达式作为操作数，求值*合并(combination)* 。

　　被作为操作符的值应是合并子右值或引用合并子对象的左值，求值合并的作用是调用对应的合并子；否则，求值失败，引起错误。

## 函数

　　成功调用合并子的表达式是*函数调用(function call)* 表达式*。在最终调用合并子的操作符位置的求值为合并子左值或右值的非列表表达式是*函数(function)* 。

　　函数是合并子右值、合并子左值（引用值）或求值为这些值的符号。

　　合并子调用的结果是函数调用的结果，称为*函数值(function value)* 。

　　特定的函数总是用来创建特定类型值的对象（右值）。这类函数是（特定类型值的）*构造器(constructor)* 。

## 中缀变换

　　中缀变换的 `<transformed-infix>` 在被求值时在操作符的位置，起到函数的作用。

　　以下中缀记号中缀变换函数的调用具有以下语义：

* `;` 求值同标准库函数 `$sequence` 。
* `,` 求值同标准库函数 `list%` 。

## 一等实体

　　程序引入或可被程序操作的 Unilang 实体在基础语言中是*一等实体(first-class entity)* 。一等实体总是可被作为操作数（用以调用函数）或作为函数调用的求值结果。

　　若一等实体是对象，它是*一等对象(first-class object)</a>* 。

　　相较于其它语言，基础语言不附加限制区分非一等的实体。这有利于同时提升简单性和一致性。区分一等对象和一等实体并不是限制，

　　本文档和派生实现的语言规则可能引用其它的非一等对象。

　　特别地，环境是一等实体；程序可在基础语言中指定不同的环境进行求值。但为可用性，环境的绑定和父环境这些状态都不是直接的一等实体。访问环境对象时，它们不被环境对象的同一性影响，而是共享的。

　　为灵活控制对象所有权，避免循环引用且允许检查误用，一等环境可能对上述共享的资源实体具有所有权。大部分情况一等环境是共享环境状态的*弱引用(weak reference)* ，不具有所有权；其它情形一等环境对环境状态具有共享的所有权。

　　此外，为满足环境的*稳定性(stability)* 即其中变量绑定不可变，可通过附加的检查机制限制绑定修改。稳定的环境可作为其它环境的父环境，称为*隐藏环境(hidden environment)* 。隐藏环境可被名称解析利用，但不能被直接访问，而不是一等对象。

## 实体表示

　　除非另行指定，实体的值使用以下规则定义的*外部表示(external represetntation)* ：

* 对列表，输出的表示是以 `(` 和 `)` 作为边界，元素以单个 ` ` 为分隔符的序列，其中的元素被递归地嵌套输出。
* 对非列表的存在对应字面量的值，输出这个值的字面量形式。
* 对引用值，输出被引用对象。
* 其它值的外部表示未指定。

# 语言和程序接口约定

　　Unilang 实现环境应满足以上基础语言的语法和语义规则，并按以下的约定提供程序接口。

## 程序实现

　　语言实现外的程序是*用户程序(user program)* 。

　　以 Unilang 程序或派生语言实现指定的其它形式实现的可复用程序被归类为*库(library)* 。

　　语言特性包含不依赖库的*核心语言特性(core language feature)* 和*库特性(library feature)* 。本章之前的所有语言特性都是核心语言特性。

　　除非另行指定，一个 Unilang 程序支持多个库的实例，之间不共享内部的状态。

## 接口文法

　　描述语言规则和程序接口的元语言使用以下语法：

* `...` Kleene 星号，重复之前修饰的项 0 次或多次。
* `+`  重复之前修饰的项 1 次或多次。
* `?`  重复之前修饰的项 0 次或 1 次。

　　实体元素使用以 `<>` 包含的格式。注意基础语言中仍可出现同名的标识符，但此处不按标识符解释。

　　未求值的操作数：

* `<symbol>` 符号。
* `<symbols>` 元素为 <symbol> 的列表，形式为 (<symbol>...) 。
* `<eformal>` 表示可选提供的环境名称或 `#ignore` 的符号。使用和 <symbol> 相同的表示。通常为动态环境。
* `<expression>` 待求值的表达式。
* `<expressions>` 形式为 `<expression>...` 的待求值形式。
	* 求值时被作为单一表达式，代替 `<expression>` 可避免语法中要求谁过多的括号及 `eval` 等求值形式中显式构造列表的需要。
* `<binding>` 绑定列表，形式为 <symbol> <expressions> ，用于指定被求值的表达式和绑定参数的符号。
* `<bindings>` 元素为 <binding> 的列表，形式为 (<binding>...) 。
* `<body>` 出现在元素的末尾 `<expressions>?` 形式，用于函数体等替换求值的目标。
* `<expression-sequence>` ：同 `<body>` 但蕴含顺序求值。
	* 求值 `<expression-sequence>` 的结果被定义为求值其最后一个子表达式（若存在）的结果，或当不存在子表达式时为 `#inert` 。
* `<consequent>` 同 `<expression>` 仅用于 `<test>` 求值为 `#t` 时。
* `<alternate>` 同 `<expression>` ，仅用于 `<test>` 求值不为 `#t` 时。
* `<definiend>` 被绑定项的目标，是包含符号的有向无环图表达式。
* `<formals>` 形式参数形式。同 `<definiend>` 但允许派生实现定义更多检查。
* `<clauses>` 元素为条件分支的列表，形式为 `(<test> <body>)...` 。
* `<variable>` 变量。用于表示被定义的名称。同 `<symbol>` ，其中的处理与作为非列表的 `<formals>` 相同。

　　求值得到的操作数：

* `<object>` 一般对象，包括引用对象的引用值。
* `<reference>` 对象引用值。
* `<list>` 列表。
* `<lists>` 元素都是列表的列表。
* `<bool>` 布尔值，值为 `#t` 或 `#f` 的集合。
* `<test>` 类似 `<object>` ，通常预期为 `<bool>` ，作为条件。当值非 `#f` 时条件成立。 
* `<combiner>` 合并子。
* `<applicative>` 应用子。
* `<predicate>` 谓词，是应用操作数的求值结果的值为 `<test>` 的 `<applicative>` 。
* `<environment>` 一等环境。

　　操作数在操作的描述中作为约束。

　　为区分同类约束的不同项，约束的名称后（在 `>` 之前）的可带有以 1 起始的正整数序数。除非另行指定，这些序数仅用于区分不同的同类约束项，无其它附加含义。

　　求值得到的参数操作数约束隐含了操作接受的形式参数的值的类型。

　　函数可指定操作数的形式。对求值得到的参数，约束指定的操作数的类型，且实现应总是蕴含类型检查。类型检查失败时，引起错误。

　　库可以和本节相容的形式补充只在库中引用的操作数。除非另行指定，被作为约束使用的新引入的类型和其它类型都不同。

## 安全性

　　不同操作提供不同的安全保证，确保满足特定条件的使用不会引入未定义行为。

　　访问不保证有效的[间接值](#间接值)的操作是不安全[间接值](#间接值)访问。

　　语言提供关于[内存安全](#内存安全)的基本保证：不存在引起内存安全以外的未定义行为的操作且不存在不安全间接值访问时，程序执行保证内存安全。

**注释** 互操作可能不满足以上保证。

### 保留间接值

　　函数返回（在对象语言中允许出现的）间接值时，保留返回值的间接值。

　　函数在环境中绑定间接值或包含（在语言中允许出现的）间接值（如列表中以一等环境作为元素）作为子对象的对象时，保留环境的间接值。

　　函数返回包含间接值的对象由（在对象语言中允许出现的）参数决定时，保留参数的间接值。

　　保留返回值的间接值、环境的间接值或保留参数的间接值的函数保留间接值。

　　保留间接值作为返回值可能因间接值无效（如悬空引用）破坏内存安全。

　　保留环境的间接值时，应保证环境具有足够的生存期，以避免间接值依赖无效的环境引用（如引用值引用已不存在的关联环境导致访问环境中对象的未定义行为。

　　按被保留的间接值的来源，保留间接值分为以下两个子类：

* 直接保留间接值：接受间接值参数；
* 间接保留间接值：接受的参数或参数在特定环境中被求值得到的结果决定是否直接保留间接值。

### 接口的安全保证机制

　　对象语言接口的安全保证机制提供不同接口的分类，通过允许区分是否具有内存安全保证的接口帮助程序利用语言基本内存安全保证。

　　[保留间接值](#保留间接值)适用引用值。除非另行指定，保留的引用值被引用折叠。

**注释** 通过要求引用折叠，可保证不引入引用的引用。

　　部分操作总是返回非引用值，以满足具体操作的语义要求，减少误用的可能性，并帮助提供内存安全保证。

　　返回非引用值的行为等价蕴含[返回值转换](#引用值和初始化)：若按其它规则返回的值是引用值，则实际返回这个引用值关联的被引用对象。这可约束作为间接值的引用值不逃逸(escape)（即使用被引用对象的值时不超出指向对象的生存期），而保证只考虑返回值可能是引用值时的内存安全。

　　其它操作可返回引用值。是否保留引用值按以下的[操作名称约定](#操作名称约定)的函数命名规则确定。

　　[间接保留引用值](#保留间接值)可包含部分直接[转发](#操作数约定)引用值的情形。包含这种情形的操作不因此被视为直接保留引用值，即便部分引用通过直接转发引用值被保留。这保证以上两个子类不相交。

　　[直接保留引用值](#保留间接值)覆盖常规函数约定的实际参数约定，指定参数不隐含[左值到右值转换](#引用值和初始化)，可按引用值直接访问。

# 基础语言实现环境

　　Unilang 以环境的绑定作为公开的接口提供库特性。

　　基础语言提供一个*基础环境(ground environment)* ，其中蕴含的变量绑定（包括包含的变量绑定和可能通过环境子对象提供的变量绑定）提供上述的主要的特性，作为程序应用程序的编程接口，也是语言扩展和应用程序的可编程性的基础。基础环境应包含语言规范要求提供的所有绑定，且不包含名称除保留名称外的绑定。

　　基础语言的用户程序初始的当前环境是一个包含基础环境作为直接或间接父环境的空环境。基础环境在此是隐藏环境，确保程序执行时不改变基础环境中的绑定。为此，基础环境自身不是以一等环境提供的库特性，而是核心语言特性。

　　基础环境的绑定提供的特性有两类：对象和*操作(operation)* 。应被支持的操作以具有明确名称的函数进行指定，参见以下章节。

　　库特性按分为*基本的(primitive)* 和*派生的(derived)* 。前者在设计上不分解为更小的其它特性的组合；后者可由基础语言代码实现。本文档中不明确指定派生的特性是否使用以基础语言源程序进行派生的形式实现。

　　本文档中约定的在基础环境中的特性中，以库提供的总称为*标准库(standard library)* 。本文档中的库特性都是标准库特性。

## 模块

　　以绑定提供的语言特性被分组归类为*模块(module)* 。

　　模块的*源(source)* 提供特性的实现。

　　因为模块以绑定的集合的形式提供，需被包含在可访问的环境，或包含环境作为子对象的其它对象中。

　　从模块的源得到提供一个模块的所有绑定集合的环境对象的过程称为模块的*加载(loading)* 。
　　模块加载可能失败。失败的模块加载引起错误。

　　标准库模块的加载失败不被直接依赖这些环境的用户程序处理（而视为实现初始化的运行时错误）。

　　一般地，模块和加载模块得到的环境对象没有直接对应关系：一个模块的绑定可以由一个或多个环境提供，一个已被加载的环境可能提供零个或多个程序可见的模块。但除非另行指定，一个模块的绑定不在超过一个的不相交的环境（之间没有直接或间接父环境关系）中提供。

　　程序可通过加载外部模块来源取得模块。除非另行指定，这种模块以一个一等环境对象（可包含作为环境的直接或间接子对象）中的绑定提供。

　　标准库包括以下模块：

* 标准库基本对象和操作。
* *核心库(core library)* ：提供直接绑定在基础环境中的派生操作的标准库子集。
* 标准 I/O 库。

　　除绑定可能在不同环境直接提供外，不同模块的边界不被要求在基础语言的实现中区分。

　　派生实现可以库的形式提供语言扩展或其它功能特性，扩充标准库。

　　以下各节的约定对标准库函数有效，用户程序不被要求。

## 操作名称约定

　　对应合并子是操作子的函数以 `$` 起始。

　　作为谓词的函数名以 `?` 结尾。

　　为改变对象而直接（而不是通过指定参数求值）蕴含副作用函数名以 `!` 结尾。

　　若函数提供结果无条件保留引用值和不保留引用值的不同版本且保留引用值的函数是不安全函数，保留引用值的函数名以 `%` 作为（在可能的 `!` 之前的）后缀。

## 不安全操作

　　不安全(unsafe) 操作是可能在程序的执行中引入未定义行为的操作。

　　这里的未定义行为包含在操作中直接引入的未定义行为，以及因为操作被执行而使程序在之后无法确保排除的未定义行为。

　　不安全操作是实现可选提供的。这些操作可能因不同理由在操作中或操作之后的程序中引入未定义行为：

* 保留可能无效的间接值：
	* 保留可能无效的引用值（如[悬空引用](#中间值)）。
	* 保留可能无效的环境引用。
* 可能因为操作环境强引用而引入循环引用。
* 可能引入数据竞争。
* 是其它另行指定的可能引入未定义行为的操作。

**注释** 当前语言不支持并发访问对象。数据竞争仅可由和宿主语言的互操作引入。

　　通过避免或限制使用具体的不安全操作，可实现上述安全保证。

　　除非另行指定，执行时包含以下操作的操作是不安全操作：

* 以下不具有内存安全保证的操作：
	以下相关章节按[操作名称约定](#操作名称约定)的保留引用值的操作。
	其它保留间接值的操作。
* 以下可能引入[循环引用](#引用值和初始化)的操作：
	引入引用现有环境的环境强引用的操作。
* 其它另行指定的操作。

**注释** 互操作可包含和以上操作等效的不安全操作。

## 操作数约定

　　一些求值为引用值的函数实际参数被保留，而不进行[左值到右值转换](#引用值和初始化)。这些值以保留值类别不变的形式被直接作为操作数，用于调用其它合并子。这种参数被*转发(forward)* 。

**注释** 参数转发类似 [ISO C++] 的 `auto&&` 推导的参数值的转发。

## 操作结果约定

　　若以下关于操作的描述中未指定调用的求值结果，则结果为右值 `#inert` 。

　　除非另行指定，没有明确在操作结果中保留引用值的其它一些操作的结果进行返回值转换：一次引用值提升转换和可选的临时对象实质化转换的复合。

　　若函数是用于返回非引用值的*构造器(constructor)* ，则可能提供不同的变体：

* 实际参数发生左值到右值转换。这减少悬空引用的可能性。
* 实际参数不发生左值到右值转换。这是不安全操作，但可以确保构造的对象中包含参数指定的引用值。

### 保留引用值的操作子

　　部分函数是选取特定实际参数求值用以确定结果的操作子。这类操作子结果直接是求值的参数，保留引用值而不进一步转换。

# 标准库接口

　　本章指定标准库提供的具体程序接口。

## 标准库对象

　　标准库的对象在基础环境中直接提供绑定。

　　标准库提供对象 `ignore` ，其值为符号 `#ignore` ，在特定操作中表示被忽略的值。

## 标准库基本操作

　　标准库基本操作在基础环境中直接提供绑定。

`eq? <object1> <object2>`

　　判断引用相等关系。当且仅当对象同一时引用相等。

`eq? <object1> <object2>`

　　判断非列表的值相等关系。当且对象转换的右值相等时比较结果为 `#t` 。比较列表对象是否相等未指定。

`$if <test> <consequent> <alternate>`

　　条件分支，按条件成立与否返回 `<consequent>` 或 `<alternative>` 之一，可能是引用值。

`$if <test> <consequent>`

　　省略第三操作数的条件分支，条件成立时返回 `<consequent>` 。若<test> 求值为 #f ，则结果为 `#inert` 。

`null? <object>`

　　判断操作数是否为空列表。

`bound-lvalue? <object>`

　　判断操作数是否为被引用的被绑定对象左值。

**注释** 绑定临时对象的引用类型的参数不被视为左值引用。

`move! <object>`

　　转移对象。

　　若参数是不可修改的左值，则以复制代替转移；否则，直接转移参数对象。

　　结果是不经返回值转换的项。

`cons <object> <list>`

　　构造两个元素的列表。

　　因为不支持列表中存在环，因此第二个操作数应为列表，否则引起错误。

`eval <expression> <environment>`

　　在参数指定的环境中求值，结果作为函数值。

`eval% <expression> <environment>`

　　同 `eval` ，但保留引用值。

`$resolve-identifier <symbol>`

　　解析标识符。

　　直接保留解析结果中项的类型，不按成员访问规则确定值类别，因此和解析名称表达式的结果总是左值不同，可保留消亡值。

`lock-environment <environment>`

　　锁定环境：创建环境强引用。

　　检查操作数的环境弱引用，结果为对应的环境强引用。

**注释** 强引用可能引起环境之间的不被检查的[循环引用](#引用值和初始化)，用户应自行避免未定义行为。

`make-environment <environment>...`

　　创建以参数为父环境的环境。

　　创建的环境是强引用。

`$def! <definiend> <expressions>`

　　修改当前环境中的绑定。

　　类似 <formals> ，<definiend> 支持递归匹配。

`$vau/e <environment> <formals> <eformal> <body>`

　　创建指定静态环境的 vau 抽象（关于 vau 抽象，参见 [Shu10] ）。

　　创建的抽象是 <environments> 求值后的环境为*静态环境(static environment)* 的操作子。静态环境是用于创建调用时的新环境的父环境。

　　<formals> 是指定*形式参数(formal parameter)* 表达式，应为以符号为非分支节点的有向无环图。由于不支持引用值，实际上是树，非分支节点是树的叶节点，分支节点是列表。

　　<eformal> 是指定*动态环境(dynamic environment)* 的表达式，应为符号。动态环境是发生调用处的当前环境。

　　<formals> 被用于在合并子调用时匹配操作数树，参数匹配算法如下：

* 初始化 <formals> 为当前形式参数，函数合并（包括作为合并子的第一个子项和作为操作数的之后余下的子项）作为当前操作数。
* 对每一对当前形式参数和当前操作数，比较两者（除非另行指定，操作数的值是引用值的，视为匹配被引用对象，下同）：
	* 若两者都是列表，则：
		* 若形式参数列表元素的末尾元素不是符号也不是列表，则参数匹配失败。
		* 若形式参数列表元素的末尾元素是以 `.` 起始的符号，则存在*省略(ellipsis)* ；保存移除 `.` 的符号，并从子项中移除末尾元素，继续进行比较。
		* 若形式参数和操作数的（直接）子节点数（作为实际参数时的列表元素数）相等，或存在省略时移除末尾元素后的形式参数元素数不大于操作数子节点的元素数，则：
			* 除被保存的省略的元素外，以深度优先搜索从左到右逐一递归匹配两者的元素。
			* 对省略的元素，若保存移除 `.` 的符号非空，创建一个列表对象保存匹配的操作数中的零个或多个对象，绑定到以保存的符号作为名称的变量。
			* 否则，所在的形式参数列表的末尾元素是 `.` ，忽略操作数，不绑定对象。
		* 否则，若不存在省略，列表的元素数不相等，参数匹配失败。
		* 否则，操作数的子节点不足，参数匹配失败。
	* 若形式参数不是符号，则参数匹配失败。
	* 若形式参数是不等于 `#ignore` 的符号，则尝试绑定操作数到以符号确定的名称的形式参数。
		* 若符号是 `&` 或 `%` 起始的*标记字符(sigil)* ，则被绑定的变量名中去除此前缀。
		* 若去除前缀得到的符号为空，则忽略操作数，不绑定对象。
	* 否则，忽略操作数，不绑定对象。

　　创建绑定时形式参数对应的变量被操作数初始化。形式参数中具有的前缀影响被绑定的变量的初始化方式。

* 若操作数为可转移的对象的引用值，则：
	* 有标记字符时，使用引用推断规则，绑定变量为通过操作数直接初始化的引用值。
	* 没有标记字符时，绑定变量为操作数复制初始化的值。
	* 被绑定对象（引用值）的标签由操作数的（引用值）的标签决定：
		* 当有标记字符 & 时，被绑定对象（引用值）中包含绑定临时对象标签，当且仅当引用值的标签指定唯一值。
		* 否则，被绑定对象的标签和引用值的标签相同。
* 否则，若操作数标签指定可修改的唯一引用或有标记字符 % 时的唯一引用，操作数是可转移的非引用值，被绑定的对象是临时对象。
* 否则，当有标记字符 & 时，被绑定对象是操作数的引用值。
* 否则，被绑定对象是复制自操作数的值。

　　当前不检查匹配的符号是否已经被绑定，形式参数树中重复的符号引起绑定的作用未指定。

　　创建的抽象作为操作子，被调用时：

* 保存当前环境作为动态环境。
* 创建环境*守卫(guard)* 保存当前环境，之后不论调用成功或出错都会回滚保存的环境。
* 创建新的环境，并以这个新环境作为当前环境。
* 若 <eformal> 是不等于 `#ignore` 的符号则绑定动态环境（先前的当前环境）到这个以符号作为名称的变量。
* 设置操作子保存的静态环境为当前环境的父环境。
* 匹配实际参数。成功匹配时，其中绑定的对象初始化环境中的变量绑定。
* 在当前环境中以函数体 (<body>) 中的表达式的副本作为*求值结构(evaluation structure)* 进行求值。

　　类似 `$vau` ，但支持额外的求值环境作为静态环境。

　　因为支持保存环境的所有权，`$vau/e` 被设计为比 `$vau` 更基本的操作。

**注释** 不考虑所有权时，`eval` 和 `$vau` 可派生 $vau/e 。

`$vau/e% <environment> <formals> <eformal> <body>`

　　同 $vau/e ，但创建的操作子调用时保留 `<body>` 求值的引用值。

`wrap <combiner>`

　　包装合并子为应用子。

`unwrap <applicative>`

　　解包装应用子为底层的合并子。

`raise-invalid-syntax-error` <string>

　　引起包含参数指定的字符串内容的语法错误。

() make-encapsulation-type

　　创建封装类型。

　　结果是三个合并子组成的列表，其元素分别表示用于构造封装类型对象的封装(encapsulate) 构造器、判断封装类型的谓词和用于解封装(decapsulate) 的访问器。

　　封装构造器保留参数中的引用值。

## 核心库函数

　　核心库函数在基础环境中直接提供绑定。

`() get-current-environment`

　　取当前环境：取当前环境的环境弱引用。

`() lock-current-environment`

　　锁定当前环境：取当前环境的环境强引用。

`$vau <formals> <eformal> <body>`

　　创建 vau 抽象。

　　类似 `$vau/e` ，但以当前环境代替额外的求值环境作为静态环境。

`$vau% <formals> <eformal> <body>`

　　创建 vau 抽象。

　　类似 `$vau/e%` ，但以当前环境代替额外的求值环境作为静态环境。

`$lambda <formals> <body>`

　　创建 λ 抽象 。

　　和创建 vau 抽象类似，但创建的是调用时对操作数的元素求值一次的应用子，且忽略动态环境。

　　表达式项的用法和 vau 抽象类似。

`$lambda% <formals> <body>`

　　同 `$lambda` ，但创建的操作子调用时保留 `<body>` 求值的引用值。

`list <object>...`

　　创建列表（类型为 `<list>` ）对象。

`list% <object>...`

　　创建列表（类型为 `<list>` ）对象，且保留参数中的引用值。

`$set! <environment> <formals> <expressions>`

　　修改指定环境的变量绑定。

　　在当前环境求值 `<environment>` 和 `<expressions>` ，再以后者的求值结果修改前者的求值结果指定的环境中的绑定。绑定效果同使用 $def! 。

`$defv! <variable> <formals> <eformal> <body>`

　　绑定 vau 抽象，等价 `$def! <variable> $vau <formals> <eformal> <body>` 。

`$defl! <variable> <formals> <body>`

　　绑定 λ 抽象，等价 `$def! <variable> $lambda <formals> <body>` 。

`$defl%! <variable> <formals> <body>`

　　绑定 λ 抽象，等价 `$def! <variable> $lambda% <formals> <body>` 。

`$lambda/e <environment> <formals> <body>`

　　创建指定静态环境的 lambda 抽象。

　　类似 `$lambda` ，但支持显式指定的求值环境为静态环境。指定静态环境的参数含义同 `$vau/e` 。

`$defl/e! <variable> <environment> <formals> <body>`

　　绑定指定静态环境的 λ 抽象，等价 `$def! <variable> $lambda/e <environment> <formals> <body>` 。

`() make-standard-environment`

　　创建*标准环境(standard environment)* ：以基础环境作为唯一父环境的新环境。

`$sequence <expression-sequence>`

　　顺序求值。操作数非空时结果是最后的参数，可能是引用值；否则结果是 `#inert` 。

　　求值每个 <object> 的副作用包括其中临时对象的销毁都被顺序限制。

`forward! <object>`

　　转发可能是引用的值。

　　参数是右值操作数或可修改的临时对象时转移，其它情形复制。

**注释** 被转发的值若是形式参数树中的变量，一般应以带有标记字符 `&` 的形式绑定；否则，转发的不是对应的实际参数，而可能是其按值绑定的副本。

`apply <applicative> <object> <environment>`

　　在指定环境中应用。

　　同求值 `eval (cons () (cons (unwrap <applicative>) <object>)) <environment>` 。

`apply <applicative> <object>`

　　在新环境中应用。

　　同求值 `eval (cons () (cons (unwrap <applicative>) <object>)) (() make-environment)` 。

　　以上 apply 的函数值保留引用值。

`list* <object>+`

　　在列表前附加元素创建列表。

　　类似 `cons` ，但支持一个和多个操作数。

　　对一个操作数的情形返回原值，否则类似 `cons` ，检查最后一个实际参数是 <list> 。

`first <list>`

　　取列表第一个元素的值。

`rest <list>`

　　取列表第一个元素以外的元素值构成的列表。

`$defv%! <variable> <formals> <eformal> <body>`

　　绑定 vau 抽象，等价 `$def! <variable> $vau% <formals> <eformal> <body>` 。

`$defw! <variable> <formals> <eformal> <body>`

　　绑定 `wrap` 的 vau 抽象，等价 `$def! <variable> wrap ($vau <formals> <eformal> <body>)` 。

`$cond <clauses>...`

　　条件选择。

　　顺序求值 `<clause>` 中每个子项的 `<test>` ，以 `<test>` 求值结果作为条件，当条件成立时求值再求值对应的 `<body>` ，结果为求值 `<body>` 的结果。

`$when <test> <expression-sequence>`

　　条件成立时顺序求值。

　　求值 <test> ，结果作为条件，当条件成立时顺序求值 `<expression-sequence>` ，并以其求值结果作为调用的求值结果。

`$unless <test> <expression-sequence>`

　　条件不成立时顺序求值。

　　求值 <test> ，结果作为条件，当条件不成立时顺序求值 `<expression-sequence>` ，并以其求值结果作为调用的求值结果。

not? <object>

　　逻辑非。

　　若参数非 `#f` 时结果为 `#f` ，否则结果为 `#t` 。

$and? <test>...

　　逻辑与。

　　顺序短路求值。操作数为空时结果为 `#t` ；参数求值存在 `#f` 时结果为 `#f` ；否则结果为最后一个参数的值。

$or? <test>...

　　逻辑或。

　　顺序短路求值。操作数为空时结果为 `#f` ，参数求值存在不是 `#f` 的值时结果为第一个这样的值；否则结果为 `#t` 。

`accr <object1> <predicate> <object2> <applicative1> <applicative2> <applicative3>`

　　在抽象列表的元素上应用右结合的二元操作。

　　对 <object1> 指定的抽象列表进行处理，取得部分和。

　　当谓词 <predicate> 成立时结果为参数指定的对象，否则继续处理抽象列表中余下的元素。

　　处理抽象的列表的操作通过余下的应用子分别定义：取列表头、取列表尾和部分和的二元合并操作。

`foldr1 <applicative> <object> <list>`

　　同 `accr` ，但指定谓词为 `null?` ，应用子分别为 `first` 和 `rest` 。

`map1 <applicative> <list>`

　　单列表映射操作，使用指定应用子对列表中每个参数进行调用，结果为调用结果的列表。

　　任意两个调用之间的相对求值顺序未指定。

`list-concat <list1> <list2>`

　　取顺序连接的列表。

`append <list>...`

　　顺序拼接列表。

`filter <predicate> <list>`

　　在列表参数中选取经谓词判断非 `#f` 的元素的值的副本创建新的列表。创建的列表的元素的顺序和列表参数中的一致。

**注释** 调用谓词的求值顺序未指定。

`derive-current-environment <environment>...`

　　创建当前环境的派生环境。

　　创建参数指定的环境和当前环境作为父环境的空环境。

`$as-environment <body>`

　　求值表达式构造环境。

　　创建以动态环境为父环境的空环境，并在其中求值参数指定的表达式。

　　结果是创建的环境强引用。

`$let <bindings> <body>`

　　局部绑定求值：创建以当前环境为父环境的空环境，在其中添加 <bindings> 指定的变量绑定，再求值 <body> 。

`$let/d <bindings> <eformal> <body>`

　　同 `$let` ，但在 <body> 的求值前引入绑定到动态环境的变量 <eformal> 。

　　若 <eformal> 为 `#ignore` ，作用同 `$let` 。

`$let* <bindings> <body>`

　　顺序局部绑定求值。

　　同 `$let` ，但 <bindings> 中的被用于绑定的表达式从左到右顺序求值，被用于初始化变量的表达式在求值时可访问 <bindings> 中之前绑定的符号。

`$letrec <bindings> <body>`

　　顺序局部绑定求值，允许递归引用绑定。

`$bindings/p->environment (<environment>...) <binding>...`

　　转换绑定列表为以指定的环境列表中的环境为父环境的具有这些绑定的环境。

`$bindings->environment <binding>...`

　　转换绑定列表为没有父环境的具有这些绑定的环境。

`$provide/let! <symbols> <bindings> <body>`

　　在当前环境中提供绑定：蕴含 $let <bindings> <body> ，在求值 <body> 后以结果作为操作数绑定到 <symbols> 的符号。

　　<symbols> 应能被作为 <defindend> 使用。

　　结果是对这些绑定具有所有权的环境强引用。

**注释** 绑定后的符号可通过作为 vau 抽象的父环境等形式依赖这个环境，因此用户需适当保存返回值使其生存期覆盖在被使用的绑定符号指称的对象生存期。

`$provide! <symbols> <body>`

　　求值第二参数并在当前环境绑定结果到第一参数指定的符号。

　　结果是带有这些绑定的环境。

`$import! <environment> <symbols>`

　　从第一参数指定的环境导入第二参数指定的符号。

## 字符串操作

　　字符串操作加载为基础环境下的 `std.string` 环境。

`string-empty? <string>`

　　判断字符串是否为空。

## 算术操作

　　算术操作在基础环境中直接提供绑定。

　　算术操作支持以下求值得到的操作数：

* `<int>` 整数类型。

`<?` <int> <int>
`<=?` <int> <int>
`>=?` <int> <int>
`>?` <int> <int>

　　数值关系操作，分别为：小于、小于等于、大于等于和大于。返回 <bool> 类型的比较结果。

**注释** 整数类型对应 C++ 的 `int` 类型。未来可能添加和改变不同数值类型的支持。

## 标准 I/O 库

　　标准 I/O 库的操作在基础环境中直接提供绑定。

`load` <string>

　　加载参数指定的翻译单元。

　　当前实现中的参数为文件系统路径。

　　被加载的翻译单元视为对象的外部表示 ，经读取翻译为 Unilang 对象。

　　求值被加载后读取的对象，并以其求值结果作为表达式的求值结果。

`display <object>`

　　输出对象的外部表示。

`() newline`

　　输出换行。

## 辅助标准库功能

　　包含当前设计中未归类的以标准库提供的辅助运行时功能。

`random.choice <list>`

　　若参数非空，随机选择其元素作为结果；否则引起错误。

## 系统互操作

　　系统互操作包含和外部实现环境交互的操作。

`sys.exit <int>`

　　以指定返回值退出进程。相当于调用 C++ 标准库的 `std::exit` 。

## 外部语言交互接口

　　外部语言交互接口是支持系统交互的底层 API ，主要以外部函数接口(FFI, foreign function interface) 的形式体现，支持调用 C 语言和兼容二进制实现的动态库中的函数。

　　外部语言交互支持以下求值得到的操作数：

* `<ffi-library>` FFI 库对象，表示一个适用外部语言交互的动态库的对象。
* `<ffi-call-interface>` FFI 调用接口对象，描述使用 FFI 调用函数需要的参数和返回类型信息。

　　系统互操作在基础环境中直接提供绑定。

`ffi-library? <object>`

　　判断参数是否为 `<ffi-library>` 对象的类型谓词。

`ffi-load-library <string>`

　　从参数指定的外部位置加载动态库。求值的结果是表示加载的动态库的 `<ffi-library>` 对象。

`ffi-call-interface? <object>`

　　判断参数是否为 `<ffi-call-interface>` 对象的类型谓词。

`ffi-make-call-interface <string1> <string2> <list>`

　　创建 FFI 调用接口。

　　参数分别为表示 ABI 的字符串、表示返回类型的字符串和一个表示函数参数类型的字符串的列表。

　　当前支持的 ABI 应为 `"FFI_DEFAULT_ABI"` 。

　　支持的类型表示如下：

* `"string"` 以指针编码的 C 字符串。对应语言内的 `string` 类型。
* `"void"` 仅用于返回值类型 `void` 。
* `"sint"` 类型 `int` 。
* `"sint"` 类型 `int` 。
* `"pointer"` 以 `void*` 编码的对象指针类型。
* `"uint8"` 类型 `uint8_t` 。
* `"sint8"` 类型 `int8_t` 。
* `"uint16"` 类型 `uint16_t` 。
* `"sint16"` 类型 `int16_t` 。
* `"uint32"` 类型 `uint32_t` 。
* `"sint32"` 类型 `int32_t` 。
* `"float"` 类型 `float` 。
* `"double"` 类型 `double` 。

`ffi-make-applicative <ffi-library> <string> <ffi-call-interface>`

　　创建以 FFI 调用 C 函数的应用子。

　　参数指定 FFI 库、函数名称和 FFI 调用接口。

　　不支持 C 函数的可变参数。

`ffi-make-callback <applicative> <ffi-call-interface>`

　　创建 FFI 回调函数对象。

